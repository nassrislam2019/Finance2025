<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>دفتر حساباتي — API فقط</title>
  <meta name="description" content="API محلي لدفتر حساباتي بدون واجهة مستخدم" />
</head>
<body>
  <!-- هذه الصفحة لا تحتوي على واجهة. كل الوظائف متاحة عبر window.DafatirAPI -->
  <script>
    /**
     * Dafatir API (No UI)
     * - يحتفظ بكل المنطق والبيانات كما في النسخة الأصلية
     * - يعرّض وظائف برمجية للتعامل مع الحسابات، الحركات، البنود (payables/receivables)، والتصدير/الاستيراد
     * - يخزن محلياً في localStorage تحت المفتاح DB_KEY
     *
     * الاستخدام في الكونسول:
     *   await Dafatir.init();                    // يحمّل أو يهيئ بيانات العينة
     *   Dafatir.listAccounts();
     *   Dafatir.addAccount('حساب جديد', 100);
     *   Dafatir.addTransaction({ type:'income', date: new Date().toISOString(), to: accId, amount: 250 });
     *   Dafatir.getDashboardSummary();
     *   Dafatir.exportData(); // يرجع JSON
     */

    (function(global){
      const DB_KEY = 'myAccountingAppDB_v4';
      let state = { accounts: [], transactions: [], payables: [] };

      // --- صيغ ومساعدات ---
      const currencyFormatter = new Intl.NumberFormat('ar-EG', { style:'currency', currency:'EGP', minimumFractionDigits:2, maximumFractionDigits:2 });
      function formatCurrency(num){ const n = Number(num) || 0; return currencyFormatter.format(n).replace('EGP','').trim(); }
      function formatDateISO(d){ try { return new Date(d).toISOString(); } catch(e){ return new Date().toISOString(); } }

      // --- StorageService ---
      const StorageService = {
        load(){
          try {
            const raw = localStorage.getItem(DB_KEY);
            if (raw) {
              const parsed = JSON.parse(raw);
              state = parsed;
              if (!state.accounts) state.accounts = [];
              if (!state.transactions) state.transactions = [];
              if (!state.payables) state.payables = [];
              return true;
            }
          } catch(e){
            console.warn('StorageService.load failed', e);
          }
          this.saveInitial();
          return false;
        },
        save(){ localStorage.setItem(DB_KEY, JSON.stringify(state)); },
        exportData(){ return JSON.stringify(state, null, 2); },
        importData(jsonStr){
          try {
            const parsed = JSON.parse(jsonStr);
            if (!parsed.accounts || !parsed.transactions) return false;
            if (!parsed.payables) parsed.payables = [];
            state = parsed;
            this.save();
            return true;
          } catch(e){
            return false;
          }
        },
        saveInitial(){
          const cryptoUUID = () => (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('id-' + Math.random().toString(36).slice(2,11));
          const cashId = cryptoUUID();
          const bankId = cryptoUUID();
          const walletId = cryptoUUID();

          const today = new Date();
          const fiveDays = new Date(today); fiveDays.setDate(today.getDate()+5);
          const twoDaysAgo = new Date(today); twoDaysAgo.setDate(today.getDate()-2);
          const fifteenDaysAgo = new Date(today); fifteenDaysAgo.setDate(today.getDate()-15);

          state = {
            accounts: [
              { id: cashId, name: 'نقد (الخزنة)', initialBalance:2000, currentBalance:2000 },
              { id: bankId, name: 'بنك الأهلي', initialBalance:10000, currentBalance:10000 },
              { id: walletId, name: 'محفظة إلكترونية', initialBalance:500, currentBalance:500 }
            ],
            transactions: [
              { id: cryptoUUID(), createdAt: new Date('2025-11-01T10:00:00').toISOString(), date: new Date('2025-11-01T10:00:00').toISOString(), type:'income', to: bankId, from: null, amount: 5000, category:'راتب', notes:'راتب شهر أكتوبر' },
              { id: cryptoUUID(), createdAt: new Date('2025-11-02T14:00:00').toISOString(), date: new Date('2025-11-02T14:00:00').toISOString(), type:'expense', from: cashId, to: null, amount: 300, category:'فواتير', notes:'فاتورة كهرباء' },
              ...(function(){ const linked = cryptoUUID(); return [
                { id: cryptoUUID(), createdAt: new Date('2025-11-03T11:00:00').toISOString(), date: new Date('2025-11-03T11:00:00').toISOString(), type:'expense', from: bankId, to:null, amount:1000, category:'تحويل صادر', notes:'تحويل للعهدة', linkedId: linked },
                { id: linked, createdAt: new Date('2025-11-03T11:00:00').toISOString(), date: new Date('2025-11-03T11:00:00').toISOString(), type:'income', from:null, to: cashId, amount:1000, category:'تحويل وارد', notes:'تحويل للعهدة', linkedId: null }
              ]; })(),
              { id: cryptoUUID(), createdAt: new Date('2025-11-05T18:00:00').toISOString(), date: new Date('2025-11-05T18:00:00').toISOString(), type:'expense', from: walletId, to: null, amount:150, category:'مشتريات أونلاين', notes:'' },
              { id: cryptoUUID(), createdAt: new Date('2025-11-07T09:00:00').toISOString(), date: new Date('2025-11-07T09:00:00').toISOString(), type:'income', to: cashId, from: null, amount:200, category:'مبيعات', notes:'مبيعات نقدية' },
            ],
            payables: [
              { id: cryptoUUID(), type:'receivable', name:'دفعة العميل (أحمد)', amount:2500, remainingAmount:2500, dueDate: fiveDays.toISOString(), status:'pending', accountId: bankId, recurrence:'none', originalDueDate: fiveDays.toISOString(), payments:[] },
              { id: cryptoUUID(), type:'payable', name:'فاتورة الإنترنت', amount:450, remainingAmount:450, dueDate: twoDaysAgo.toISOString(), status:'pending', accountId: cashId, recurrence:'none', originalDueDate: twoDaysAgo.toISOString(), payments:[] },
              { id: cryptoUUID(), type:'payable', name:'إيجار المكتب (سابق)', amount:3000, remainingAmount:0, dueDate: fifteenDaysAgo.toISOString(), status:'paid', accountId: bankId, recurrence:'none', originalDueDate: fifteenDaysAgo.toISOString(), payments:[] },
              { id: cryptoUUID(), type:'payable', name:'إيجار المكتب (شهري)', amount:3000, remainingAmount:3000, dueDate: new Date(today.getFullYear(), today.getMonth(), 1).toISOString(), status:'pending', accountId: bankId, recurrence:'monthly', originalDueDate: new Date(today.getFullYear(), today.getMonth(), 1).toISOString(), payments:[] }
            ]
          };

          this.save();
        }
      };

      // --- CoreLogic (business rules) ---
      const CoreLogic = {
        getAccountById(id){ return state.accounts.find(a => a.id === id); },
        getTransactionById(id){ return state.transactions.find(t => t.id === id); },
        getDueById(id){ return state.payables.find(p => p.id === id); },

        createTransferPair(fromId, toId, amount, dateIso, notes){
          const linkedId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('id-' + Math.random().toString(36).slice(2,11));
          const expense = { id: (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'id-'+Math.random().toString(36).slice(2,11), createdAt: dateIso, date: dateIso, type:'expense', from: fromId, to: null, amount: amount, category:'تحويل صادر', notes: notes, linkedId: linkedId };
          const income = { id: linkedId, createdAt: dateIso, date: dateIso, type:'income', from:null, to: toId, amount: amount, category:'تحويل وارد', notes: notes, linkedId: expense.id };
          return [expense, income];
        },

        recalculateAccountBalance(accountId){
          const account = this.getAccountById(accountId);
          if (!account) return;
          const accountTxs = state.transactions.filter(t => t.from === accountId || t.to === accountId)
            .sort((a,b) => new Date(a.date).getTime() - new Date(b.date).getTime() || new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
          let currentBalance = Number(account.initialBalance) || 0;
          for (const tx of accountTxs) {
            tx.balanceBefore = currentBalance;
            if (tx.type === 'income' && tx.to === accountId) currentBalance += Number(tx.amount) || 0;
            else if (tx.type === 'expense' && tx.from === accountId) currentBalance -= Number(tx.amount) || 0;
            tx.balanceAfter = currentBalance;
          }
          account.currentBalance = currentBalance;
        },

        recalculateAllBalances(){ for (const acc of state.accounts) this.recalculateAccountBalance(acc.id); },

        addAccount(name, initialBalance){
          const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'id-' + Math.random().toString(36).slice(2,11);
          state.accounts.push({ id, name, initialBalance: Number(initialBalance)||0, currentBalance: Number(initialBalance)||0 });
          this.recalculateAllBalances(); StorageService.save();
          return id;
        },

        updateAccount(id, name, initialBalance){
          const acc = this.getAccountById(id); if (!acc) return false;
          acc.name = name; acc.initialBalance = Number(initialBalance)||0;
          this.recalculateAllBalances(); StorageService.save(); return true;
        },

        deleteAccount(id){
          if (state.transactions.some(t => t.from === id || t.to === id)) return false;
          state.accounts = state.accounts.filter(a => a.id !== id);
          StorageService.save(); return true;
        },

        addTransaction(txData){
          const now = new Date().toISOString();
          if (txData.type === 'transfer') {
            const dateIso = new Date(txData.date).toISOString();
            const [expense, income] = this.createTransferPair(txData.from, txData.to, Number(txData.amount)||0, dateIso, txData.notes || '');
            state.transactions.push(expense, income);
            this.recalculateAllBalances(); StorageService.save();
            return [expense.id, income.id];
          } else {
            const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'id-' + Math.random().toString(36).slice(2,11);
            const tx = {
              id,
              createdAt: now,
              date: new Date(txData.date).toISOString(),
              type: txData.type,
              from: txData.from || null,
              to: txData.to || null,
              amount: Number(txData.amount) || 0,
              category: txData.category || '',
              notes: txData.notes || '',
              linkedId: null
            };
            state.transactions.push(tx);
            this.recalculateAllBalances(); StorageService.save();
            return id;
          }
        },

        updateTransaction(id, newTxData){
          const tx = this.getTransactionById(id); if (!tx) return false;
          if (tx.linkedId) {
            const linkedTx = this.getTransactionById(tx.linkedId);
            tx.date = new Date(newTxData.date).toISOString();
            tx.amount = Number(newTxData.amount)||tx.amount;
            tx.notes = newTxData.notes || tx.notes;
            tx.from = newTxData.from || tx.from;
            if (linkedTx) {
              linkedTx.date = tx.date;
              linkedTx.amount = tx.amount;
              linkedTx.notes = tx.notes;
              linkedTx.to = newTxData.to || linkedTx.to;
            }
          } else {
            tx.date = new Date(newTxData.date).toISOString();
            tx.amount = Number(newTxData.amount)||tx.amount;
            tx.category = newTxData.category || tx.category;
            tx.notes = newTxData.notes || tx.notes;
            tx.from = newTxData.from || tx.from;
            tx.to = newTxData.to || tx.to;
          }
          this.recalculateAllBalances(); StorageService.save(); return true;
        },

        deleteTransaction(id){
          const tx = this.getTransactionById(id);
          if (!tx) return false;
          if (tx.linkedId) state.transactions = state.transactions.filter(t => t.id !== id && t.id !== tx.linkedId);
          else state.transactions = state.transactions.filter(t => t.id !== id);
          this.recalculateAllBalances(); StorageService.save(); return true;
        },

        addDue(data){
          const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'id-' + Math.random().toString(36).slice(2,11);
          state.payables.push({ id, type: data.type, name: data.name, amount: Number(data.amount)||0, remainingAmount: Number(data.amount)||0, dueDate: data.dueDate, accountId: data.accountId, recurrence: data.recurrence || 'none', status: 'pending', originalDueDate: data.dueDate, payments:[] });
          StorageService.save(); return id;
        },

        updateDue(id, data){
          const due = this.getDueById(id); if (!due) return false;
          due.type = data.type; due.name = data.name; due.amount = Number(data.amount)||due.amount;
          if (due.status !== 'paid') due.remainingAmount = Number(data.amount)||due.remainingAmount;
          due.dueDate = data.dueDate; due.accountId = data.accountId; due.recurrence = data.recurrence;
          if (!due.originalDueDate) due.originalDueDate = data.dueDate;
          StorageService.save(); return true;
        },

        deleteDue(id){
          const due = this.getDueById(id);
          if (!due) return false;
          if (due.status === 'paid' && Array.isArray(due.payments) && due.payments.length) {
            for (const p of due.payments) {
              if (p.txId) {
                state.transactions = state.transactions.filter(t => t.id !== p.txId);
              }
            }
            due.status = 'pending';
            due.remainingAmount = due.amount;
            due.dueDate = due.originalDueDate || due.dueDate;
            due.payments = [];
            this.recalculateAllBalances(); StorageService.save();
            return 'restored';
          } else {
            state.payables = state.payables.filter(p => p.id !== id);
            StorageService.save();
            return 'deleted';
          }
        },

        applyPayment({ dueId, amount, accountId, notes, isCollection }) {
          const due = this.getDueById(dueId);
          if (!due) return { ok:false, msg:'البند غير موجود' };
          amount = Number(amount)||0;
          if (amount <= 0) return { ok:false, msg:'المبلغ غير صالح' };
          if (amount > due.remainingAmount + 0.0001) return { ok:false, msg:'المبلغ أكبر من المتبقي' };

          const nowIso = new Date().toISOString();
          let tx = null;
          if (isCollection) {
            tx = { id: (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'id-'+Math.random().toString(36).slice(2,11), createdAt: nowIso, date: nowIso, type:'income', from:null, to: accountId, amount, category:'تحصيل', notes: notes || `تحصيل: ${due.name}` };
          } else {
            tx = { id: (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'id-'+Math.random().toString(36).slice(2,11), createdAt: nowIso, date: nowIso, type:'expense', from:accountId, to:null, amount, category:'سداد', notes: notes || `سداد: ${due.name}` };
          }
          state.transactions.push(tx);

          due.payments = due.payments || [];
          due.payments.push({ amount, date: nowIso, accountId, txId: tx.id });

          due.remainingAmount = Math.max(0, Number(due.remainingAmount) - amount);

          if (due.remainingAmount <= 0.0001) {
            if (due.recurrence === 'monthly') {
              const next = new Date(due.dueDate);
              next.setMonth(next.getMonth()+1);
              due.dueDate = next.toISOString();
              due.remainingAmount = Number(due.amount) || 0;
              due.status = 'pending';
            } else {
              due.status = 'paid';
              if (!due.originalDueDate) due.originalDueDate = due.dueDate;
            }
          } else {
            due.status = 'pending';
          }

          this.recalculateAllBalances();
          StorageService.save();
          return { ok:true, txId: tx.id, due };
        },

        collectReceivablePartial(dueId, amount, accountId, notes=''){ const due = this.getDueById(dueId); if (!due || due.type !== 'receivable') return false; const res = this.applyPayment({ dueId, amount, accountId, notes, isCollection:true }); return res.ok; },
        payPayablePartial(dueId, amount, accountId, notes=''){ const due = this.getDueById(dueId); if (!due || due.type !== 'payable') return false; const res = this.applyPayment({ dueId, amount, accountId, notes, isCollection:false }); return res.ok; },

        getDuesWithStatus(){
          const today = new Date(); today.setHours(0,0,0,0);
          const sevenDays = new Date(today.getTime() + 7*24*60*60*1000);
          return state.payables.map(due => {
            const dueDate = new Date(due.dueDate); dueDate.setHours(0,0,0,0);
            let statusText = 'مستحق';
            if (due.status === 'paid' && (due.recurrence === 'none' || !due.recurrence)) statusText='مدفوع';
            else if (dueDate < today) statusText='متأخر';
            else if (dueDate <= sevenDays) statusText='قريب الاستحقاق';
            if (due.remainingAmount === undefined || due.remainingAmount === null) due.remainingAmount = Number(due.amount) || 0;
            return { ...due, statusText };
          }).sort((a,b) => new Date(a.dueDate) - new Date(b.dueDate));
        },

        getFilteredTransactions(filters){
          const { account='all', type='all', dateStart='', dateEnd='' } = filters || {};
          return state.transactions.filter(tx => {
            if (account !== 'all' && tx.from !== account && tx.to !== account) return false;
            if (type !== 'all' && tx.type !== type) return false;
            if (dateStart) { if (formatDateISO(tx.date).slice(0,10) < dateStart) return false; }
            if (dateEnd) { if (formatDateISO(tx.date).slice(0,10) > dateEnd) return false; }
            return true;
          }).sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime());
        },

        getTopSpendingCategories(){
          const spending = {};
          state.transactions.forEach(tx => { if (tx.type === 'expense') { const cat = tx.category || 'غير مصنف'; spending[cat] = (spending[cat] || 0) + Number(tx.amount || 0); }});
          return Object.entries(spending).map(([category, amount]) => ({ category, amount })).sort((a,b)=>b.amount-a.amount).slice(0,5);
        },

        getDashboardSummary(){
          let income=0, expense=0;
          state.transactions.forEach(tx => { if (tx.type === 'income') income += Number(tx.amount)||0; else if (tx.type === 'expense') expense += Number(tx.amount)||0; });
          const totalBalance = state.accounts.reduce((s,a) => s + (Number(a.currentBalance)||0), 0);
          const startOfMonth = new Date(); startOfMonth.setDate(1); startOfMonth.setHours(0,0,0,0);
          const endOfMonth = new Date(startOfMonth); endOfMonth.setMonth(startOfMonth.getMonth()+1); endOfMonth.setDate(0); endOfMonth.setHours(23,59,59,999);
          let payablesRemaining = 0, receivablesUncollected = 0;
          state.payables.forEach(d => {
            const dueDate = new Date(d.dueDate);
            if (dueDate >= startOfMonth && dueDate <= endOfMonth) {
              if (d.type === 'payable') payablesRemaining += Number(d.remainingAmount || d.amount || 0);
              if (d.type === 'receivable') receivablesUncollected += Number(d.remainingAmount || d.amount || 0);
            }
          });
          return { income, expense, net: income - expense, totalBalance, payablesRemaining, receivablesUncollected };
        }
      };

      // --- API layer (تعليمات مساعدة للتعامل من الخارج) ---
      const API = {
        // life-cycle
        init(){ StorageService.load(); CoreLogic.recalculateAllBalances(); return Promise.resolve(true); },

        // raw state (read-only copy)
        getState(){ return JSON.parse(JSON.stringify(state)); },

        // accounts
        listAccounts(){ return JSON.parse(JSON.stringify(state.accounts)); },
        getAccount(id){ return JSON.parse(JSON.stringify(CoreLogic.getAccountById(id))); },
        addAccount(name, initialBalance){ return CoreLogic.addAccount(name, initialBalance); },
        updateAccount(id, name, initialBalance){ return CoreLogic.updateAccount(id, name, initialBalance); },
        deleteAccount(id){ return CoreLogic.deleteAccount(id); },

        // transactions
        listTransactions(filters){ return CoreLogic.getFilteredTransactions(filters || {}); },
        getTransaction(id){ return JSON.parse(JSON.stringify(CoreLogic.getTransactionById(id))); },
        addTransaction(txData){ return CoreLogic.addTransaction(txData); },
        updateTransaction(id, txData){ return CoreLogic.updateTransaction(id, txData); },
        deleteTransaction(id){ return CoreLogic.deleteTransaction(id); },

        // dues
        listDues(){ return CoreLogic.getDuesWithStatus(); },
        getDue(id){ return JSON.parse(JSON.stringify(CoreLogic.getDueById(id))); },
        addDue(data){ return CoreLogic.addDue(data); },
        updateDue(id, data){ return CoreLogic.updateDue(id, data); },
        deleteDue(id){ return CoreLogic.deleteDue(id); },

        // payments
        applyPayment(args){ return CoreLogic.applyPayment(args); },
        collectReceivablePartial(dueId, amount, accountId, notes=''){ return CoreLogic.collectReceivablePartial(dueId, amount, accountId, notes); },
        payPayablePartial(dueId, amount, accountId, notes=''){ return CoreLogic.payPayablePartial(dueId, amount, accountId, notes); },

        // summary & helpers
        getDashboardSummary(){ return CoreLogic.getDashboardSummary(); },
        getTopSpendingCategories(){ return CoreLogic.getTopSpendingCategories(); },

        // storage
        exportData(){ return StorageService.exportData(); },
        importData(jsonStr){ return StorageService.importData(jsonStr); },
        resetToInitial(){ StorageService.saveInitial(); CoreLogic.recalculateAllBalances(); return true; }
      };

      // اربط الـ API بالنافذة (window) لاستخدامه من الكونسول أو من سكربت خارجي
      global.DafatirAPI = API;

      // init تلقائي لسهولة الاستخدام
      StorageService.load();
      CoreLogic.recalculateAllBalances();

      // Console-friendly quick helpers
      console.info('DafatirAPI جاهز. استعمل DafatirAPI.init() للتهيئة. بعض الوظائف المفيدة: listAccounts(), listTransactions(), addAccount(name,bal), addTransaction(txData), getDashboardSummary()');
    })(window);
  </script>
</body>
</html>