<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ø¯ÙØªØ± Ø­Ø³Ø§Ø¨Ø§ØªÙŠ - Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø¯Ø©</title>
  <meta name="description" content="ÙˆØ§Ø¬Ù‡Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø³ÙŠØ·Ø© Ù„Ø¯ÙØªØ± Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª" />
  <style>
    /* ----------------------------------------------------- */
    /* 1. Global & Color Variables (Day/Night) */
    /* ----------------------------------------------------- */
    :root {
      /* Default Light Mode Colors */
      --primary: #007bff;
      --secondary: #6c757d;
      --success: #28a745;
      --danger: #dc3545;
      --warning: #ffc107;
      --background: #f8f9fa;
      --card-bg: white;
      --text-color: #212529;
      --border-color: #dee2e6;
      --shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.1);
    }
    
    /* Dark Mode Override (prefers-color-scheme) */
    @media (prefers-color-scheme: dark) {
      :root {
        --background: #121212;
        --card-bg: #1e1e1e;
        --text-color: #f1f1f1;
        --border-color: #333;
        --shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.4);
        --primary: #4e9af1; /* Adjusted for contrast */
        --success: #6cff6c;
        --danger: #ff6b6b;
      }
      body { color: var(--text-color); }
    }

    /* Dark Mode Class Toggle (manual switch) */
    html.dark-mode {
      --background: #121212;
      --card-bg: #1e1e1e;
      --text-color: #f1f1f1;
      --border-color: #333;
      --shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.4);
      --primary: #4e9af1;
      --success: #6cff6c;
      --danger: #ff6b6b;
    }
    
    /* ----------------------------------------------------- */
    /* 2. Base Styling */
    /* ----------------------------------------------------- */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Arabic Naskh", "Droid Arabic Naskh";
      direction: rtl;
      margin: 0;
      padding: 0;
      background-color: var(--background);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    header {
      background-color: var(--primary);
      color: white;
      padding: 15px 20px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 { margin: 0; }
    .container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 15px;
    }

    /* ----------------------------------------------------- */
    /* 3. Dashboard Layout & Cards */
    /* ----------------------------------------------------- */
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    .card {
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow);
      transition: all 0.3s;
    }
    .card:hover {
        transform: translateY(-2px);
    }
    .card-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--primary);
      padding-bottom: 5px;
      color: var(--primary);
    }
    .summary-item h3 { font-size: 2.2rem; margin: 5px 0; font-weight: 700; }
    .summary-item p { font-size: 0.9rem; margin-top: 0; color: var(--secondary); }
    
    /* Color Highlights */
    .total-balance { color: var(--text-color); }
    .income { color: var(--success); }
    .expense { color: var(--danger); }
    .net-balance { color: var(--primary); }

    /* ----------------------------------------------------- */
    /* 4. Table Styling */
    /* ----------------------------------------------------- */
    .table-responsive { overflow-x: auto; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
      font-size: 0.95rem;
    }
    th, td {
      padding: 12px 15px;
      border: 1px solid var(--border-color);
      text-align: right;
    }
    th {
      background-color: var(--primary);
      color: white;
      font-weight: 600;
      text-align: center;
      border-color: var(--primary);
    }
    tr:nth-child(even) {
      background-color: rgba(0, 0, 0, 0.03); /* Light tint for zebra stripping */
    }
    html.dark-mode tr:nth-child(even), :not(.dark-mode) tr:nth-child(even) {
      background-color: rgba(255, 255, 255, 0.05); /* Dark tint */
    }
    
    /* Status Badges */
    .status-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.85em;
      color: white;
      font-weight: 600;
      display: inline-block;
    }
    .status-Ù…ØªØ£Ø®Ø± { background-color: var(--danger); }
    .status-Ù…Ø¯ÙÙˆØ¹ { background-color: var(--success); }
    .status-Ù‚Ø±ÙŠØ¨-Ø§Ù„Ø§Ø³ØªØ­Ù‚Ø§Ù‚ { background-color: var(--warning); color: var(--text-color); }
    .status-Ù…Ø³ØªØ­Ù‚ { background-color: var(--primary); }

    /* Utility Classes */
    .text-center { text-align: center !important; }
    .text-success { color: var(--success) !important; }
    .text-danger { color: var(--danger) !important; }
    .text-warning { color: var(--warning) !important; }
    
    /* ----------------------------------------------------- */
    /* 5. Theme Switch Button */
    /* ----------------------------------------------------- */
    #theme-toggle {
        background: none;
        border: 2px solid white;
        color: white;
        padding: 8px 15px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 1.2rem;
        transition: background-color 0.3s, border-color 0.3s;
        order: -1; /* Place it first in the flex container */
    }
    #theme-toggle:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <header>
    <button id="theme-toggle" aria-label="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ/Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ">
        â˜€ï¸
    </button>
    <h1>Ø¯ÙØªØ± Ø­Ø³Ø§Ø¨Ø§ØªÙŠ ğŸ“Š</h1>
    <p style="margin:0; opacity: 0.8;">Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©</p>
  </header>

  <div class="container">
    <div class="dashboard-grid" id="summary-cards">
      </div>
    
    <div class="dashboard-grid">
      <div class="card" id="accounts-card">
        <h2 class="card-title">ğŸ’µ Ø£Ø±ØµØ¯Ø© Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª</h2>
        <div class="table-responsive">
          <table id="accounts-table">
            <thead>
              <tr>
                <th>Ø§Ù„Ø­Ø³Ø§Ø¨</th>
                <th class="text-center">Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ (Ø¬.Ù…)</th>
              </tr>
            </thead>
            <tbody>
              </tbody>
          </table>
        </div>
      </div>

      <div class="card" id="top-spending-card">
        <h2 class="card-title">ğŸ’° Ø£Ø¹Ù„Ù‰ ÙØ¦Ø§Øª Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª (Ø£ÙˆÙ„ 5)</h2>
        <div class="table-responsive">
          <table id="top-spending-table">
            <thead>
              <tr>
                <th>Ø§Ù„ÙØ¦Ø©</th>
                <th class="text-center">Ø§Ù„Ù…Ø¨Ù„Øº (Ø¬.Ù…)</th>
              </tr>
            </thead>
            <tbody>
              </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card" id="dues-card">
      <h2 class="card-title">â³ Ø§Ù„Ù…Ø³ØªØ­Ù‚Ø§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© (Ù…Ø·Ù„ÙˆØ¨/Ù…ØªÙˆÙ‚Ø¹)</h2>
      <div class="table-responsive">
        <table id="dues-table">
          <thead>
            <tr>
              <th>Ø§Ù„Ø¨ÙŠØ§Ù†</th>
              <th class="text-center">Ø§Ù„Ù†ÙˆØ¹</th>
              <th class="text-center">ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ø³ØªØ­Ù‚Ø§Ù‚</th>
              <th class="text-center">Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ (Ø¬.Ù…)</th>
              <th class="text-center">Ø§Ù„Ø­Ø³Ø§Ø¨</th>
              <th class="text-center">Ø§Ù„Ø­Ø§Ù„Ø©</th>
            </tr>
          </thead>
          <tbody>
            </tbody>
        </table>
      </div>
    </div>
    
    <button onclick="initializeDashboard()" style="background-color: var(--success); color: white; border: none; padding: 10px 20px; border-radius: 8px; margin-top: 20px; cursor: pointer; font-size: 1rem;">ğŸ”„ ØªØ­Ø¯ÙŠØ« Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø¯Ø©</button>
  </div>

  <script>
    /**
     * Dafatir API (No UI) - Logic Core
     */
    
    (function(global){
      const DB_KEY = 'myAccountingAppDB_v4';
      let state = { accounts: [], transactions: [], payables: [] };

      // --- ØµÙŠØº ÙˆÙ…Ø³Ø§Ø¹Ø¯Ø§Øª ---
      const currencyFormatter = new Intl.NumberFormat('ar-EG', { style:'currency', currency:'EGP', minimumFractionDigits:2, maximumFractionDigits:2 });
      function formatCurrency(num){ const n = Number(num) || 0; return currencyFormatter.format(n).replace('EGP','').trim(); }
      function formatDateISO(d){ try { return new Date(d).toISOString(); } catch(e){ return new Date().toISOString(); } }
      const cryptoUUID = () => (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('id-' + Math.random().toString(36).slice(2,11));

      // --- StorageService ---
      const StorageService = {
        load(){
          try {
            const raw = localStorage.getItem(DB_KEY);
            if (raw) {
              const parsed = JSON.parse(raw);
              state = parsed;
              if (!state.accounts) state.accounts = [];
              if (!state.transactions) state.transactions = [];
              if (!state.payables) state.payables = [];
              return true;
            }
          } catch(e){
            console.warn('StorageService.load failed', e);
          }
          this.saveInitial();
          return false;
        },
        save(){ localStorage.setItem(DB_KEY, JSON.stringify(state)); },
        exportData(){ return JSON.stringify(state, null, 2); },
        importData(jsonStr){
          try {
            const parsed = JSON.parse(jsonStr);
            if (!parsed.accounts || !parsed.transactions) return false;
            if (!parsed.payables) parsed.payables = [];
            state = parsed;
            this.save();
            return true;
          } catch(e){
            return false;
          }
        },
        saveInitial(){
          const cashId = cryptoUUID();
          const bankId = cryptoUUID();
          const walletId = cryptoUUID();

          const today = new Date();
          const fiveDays = new Date(today); fiveDays.setDate(today.getDate()+5);
          const twoDaysAgo = new Date(today); twoDaysAgo.setDate(today.getDate()-2);
          const fifteenDaysAgo = new Date(today); fifteenDaysAgo.setDate(today.getDate()-15);

          state = {
            accounts: [
              { id: cashId, name: 'Ù†Ù‚Ø¯ (Ø§Ù„Ø®Ø²Ù†Ø©)', initialBalance:2000, currentBalance:2000 },
              { id: bankId, name: 'Ø¨Ù†Ùƒ Ø§Ù„Ø£Ù‡Ù„ÙŠ', initialBalance:10000, currentBalance:10000 },
              { id: walletId, name: 'Ù…Ø­ÙØ¸Ø© Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©', initialBalance:500, currentBalance:500 }
            ],
            transactions: [
              { id: cryptoUUID(), createdAt: new Date('2025-11-01T10:00:00').toISOString(), date: new Date('2025-11-01T10:00:00').toISOString(), type:'income', to: bankId, from: null, amount: 5000, category:'Ø±Ø§ØªØ¨', notes:'Ø±Ø§ØªØ¨ Ø´Ù‡Ø± Ø£ÙƒØªÙˆØ¨Ø±' },
              { id: cryptoUUID(), createdAt: new Date('2025-11-02T14:00:00').toISOString(), date: new Date('2025-11-02T14:00:00').toISOString(), type:'expense', from: cashId, to: null, amount: 300, category:'ÙÙˆØ§ØªÙŠØ±', notes:'ÙØ§ØªÙˆØ±Ø© ÙƒÙ‡Ø±Ø¨Ø§Ø¡' },
              ...(function(){ const linked = cryptoUUID(); return [
                { id: cryptoUUID(), createdAt: new Date('2025-11-03T11:00:00').toISOString(), date: new Date('2025-11-03T11:00:00').toISOString(), type:'expense', from: bankId, to:null, amount:1000, category:'ØªØ­ÙˆÙŠÙ„ ØµØ§Ø¯Ø±', notes:'ØªØ­ÙˆÙŠÙ„ Ù„Ù„Ø¹Ù‡Ø¯Ø©', linkedId: linked },
                { id: linked, createdAt: new Date('2025-11-03T11:00:00').toISOString(), date: new Date('2025-11-03T11:00:00').toISOString(), type:'income', from:null, to: cashId, amount:1000, category:'ØªØ­ÙˆÙŠÙ„ ÙˆØ§Ø±Ø¯', notes:'ØªØ­ÙˆÙŠÙ„ Ù„Ù„Ø¹Ù‡Ø¯Ø©', linkedId: expense.id }
              ]; })(),
              { id: cryptoUUID(), createdAt: new Date('2025-11-05T18:00:00').toISOString(), date: new Date('2025-11-05T18:00:00').toISOString(), type:'expense', from: walletId, to: null, amount:150, category:'Ù…Ø´ØªØ±ÙŠØ§Øª Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†', notes:'' },
              { id: cryptoUUID(), createdAt: new Date('2025-11-07T09:00:00').toISOString(), date: new Date('2025-11-07T09:00:00').toISOString(), type:'income', to: cashId, from: null, amount:200, category:'Ù…Ø¨ÙŠØ¹Ø§Øª', notes:'Ù…Ø¨ÙŠØ¹Ø§Øª Ù†Ù‚Ø¯ÙŠØ©' },
            ],
            payables: [
              { id: cryptoUUID(), type:'receivable', name:'Ø¯ÙØ¹Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„ (Ø£Ø­Ù…Ø¯)', amount:2500, remainingAmount:2500, dueDate: fiveDays.toISOString(), status:'pending', accountId: bankId, recurrence:'none', originalDueDate: fiveDays.toISOString(), payments:[] },
              { id: cryptoUUID(), type:'payable', name:'ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª', amount:450, remainingAmount:450, dueDate: twoDaysAgo.toISOString(), status:'pending', accountId: cashId, recurrence:'none', originalDueDate: twoDaysAgo.toISOString(), payments:[] },
              { id: cryptoUUID(), type:'payable', name:'Ø¥ÙŠØ¬Ø§Ø± Ø§Ù„Ù…ÙƒØªØ¨ (Ø³Ø§Ø¨Ù‚)', amount:3000, remainingAmount:0, dueDate: fifteenDaysAgo.toISOString(), status:'paid', accountId: bankId, recurrence:'none', originalDueDate: fifteenDaysAgo.toISOString(), payments:[] },
              { id: cryptoUUID(), type:'payable', name:'Ø¥ÙŠØ¬Ø§Ø± Ø§Ù„Ù…ÙƒØªØ¨ (Ø´Ù‡Ø±ÙŠ)', amount:3000, remainingAmount:3000, dueDate: new Date(today.getFullYear(), today.getMonth(), 1).toISOString(), status:'pending', accountId: bankId, recurrence:'monthly', originalDueDate: new Date(today.getFullYear(), today.getMonth(), 1).toISOString(), payments:[] }
            ]
          };

          this.save();
        }
      };

      // --- CoreLogic (business rules) ---
      const CoreLogic = {
        getAccountById(id){ return state.accounts.find(a => a.id === id); },
        getTransactionById(id){ return state.transactions.find(t => t.id === id); },
        getDueById(id){ return state.payables.find(p => p.id === id); },

        createTransferPair(fromId, toId, amount, dateIso, notes){
          const linkedId = cryptoUUID();
          const expense = { id: cryptoUUID(), createdAt: dateIso, date: dateIso, type:'expense', from: fromId, to: null, amount: amount, category:'ØªØ­ÙˆÙŠÙ„ ØµØ§Ø¯Ø±', notes: notes, linkedId: linkedId };
          const income = { id: linkedId, createdAt: dateIso, date: dateIso, type:'income', from:null, to: toId, amount: amount, category:'ØªØ­ÙˆÙŠÙ„ ÙˆØ§Ø±Ø¯', notes: notes, linkedId: expense.id };
          return [expense, income];
        },

        recalculateAccountBalance(accountId){
          const account = this.getAccountById(accountId);
          if (!account) return;
          const accountTxs = state.transactions.filter(t => t.from === accountId || t.to === accountId)
            .sort((a,b) => new Date(a.date).getTime() - new Date(b.date).getTime() || new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
          let currentBalance = Number(account.initialBalance) || 0;
          for (const tx of accountTxs) {
            tx.balanceBefore = currentBalance;
            if (tx.type === 'income' && tx.to === accountId) currentBalance += Number(tx.amount) || 0;
            else if (tx.type === 'expense' && tx.from === accountId) currentBalance -= Number(tx.amount) || 0;
            tx.balanceAfter = currentBalance;
          }
          account.currentBalance = currentBalance;
        },

        recalculateAllBalances(){ for (const acc of state.accounts) this.recalculateAccountBalance(acc.id); },

        addAccount(name, initialBalance){
          const id = cryptoUUID();
          state.accounts.push({ id, name, initialBalance: Number(initialBalance)||0, currentBalance: Number(initialBalance)||0 });
          this.recalculateAllBalances(); StorageService.save();
          return id;
        },

        updateAccount(id, name, initialBalance){
          const acc = this.getAccountById(id); if (!acc) return false;
          acc.name = name; acc.initialBalance = Number(initialBalance)||0;
          this.recalculateAllBalances(); StorageService.save(); return true;
        },

        deleteAccount(id){
          if (state.transactions.some(t => t.from === id || t.to === id)) return false;
          state.accounts = state.accounts.filter(a => a.id !== id);
          StorageService.save(); return true;
        },

        addTransaction(txData){
          const now = new Date().toISOString();
          if (txData.type === 'transfer') {
            const dateIso = new Date(txData.date).toISOString();
            const [expense, income] = this.createTransferPair(txData.from, txData.to, Number(txData.amount)||0, dateIso, txData.notes || '');
            state.transactions.push(expense, income);
            this.recalculateAllBalances(); StorageService.save();
            return [expense.id, income.id];
          } else {
            const id = cryptoUUID();
            const tx = {
              id,
              createdAt: now,
              date: new Date(txData.date).toISOString(),
              type: txData.type,
              from: txData.from || null,
              to: txData.to || null,
              amount: Number(txData.amount) || 0,
              category: txData.category || '',
              notes: txData.notes || '',
              linkedId: null
            };
            state.transactions.push(tx);
            this.recalculateAllBalances(); StorageService.save();
            return id;
          }
        },

        updateTransaction(id, newTxData){
          const tx = this.getTransactionById(id); if (!tx) return false;
          if (tx.linkedId) {
            const linkedTx = this.getTransactionById(tx.linkedId);
            tx.date = new Date(newTxData.date).toISOString();
            tx.amount = Number(newTxData.amount)||tx.amount;
            tx.notes = newTxData.notes || tx.notes;
            tx.from = newTxData.from || tx.from;
            if (linkedTx) {
              linkedTx.date = tx.date;
              linkedTx.amount = tx.amount;
              linkedTx.notes = tx.notes;
              linkedTx.to = newTxData.to || linkedTx.to;
            }
          } else {
            tx.date = new Date(newTxData.date).toISOString();
            tx.amount = Number(newTxData.amount)||tx.amount;
            tx.category = newTxData.category || tx.category;
            tx.notes = newTxData.notes || tx.notes;
            tx.from = newTxData.from || tx.from;
            tx.to = newTxData.to || tx.to;
          }
          this.recalculateAllBalances(); StorageService.save(); return true;
        },

        deleteTransaction(id){
          const tx = this.getTransactionById(id);
          if (!tx) return false;
          if (tx.linkedId) state.transactions = state.transactions.filter(t => t.id !== id && t.id !== tx.linkedId);
          else state.transactions = state.transactions.filter(t => t.id !== id);
          this.recalculateAllBalances(); StorageService.save(); return true;
        },

        addDue(data){
          const id = cryptoUUID();
          state.payables.push({ id, type: data.type, name: data.name, amount: Number(data.amount)||0, remainingAmount: Number(data.amount)||0, dueDate: data.dueDate, accountId: data.accountId, recurrence: data.recurrence || 'none', status: 'pending', originalDueDate: data.dueDate, payments:[] });
          StorageService.save(); return id;
        },

        updateDue(id, data){
          const due = this.getDueById(id); if (!due) return false;
          due.type = data.type; due.name = data.name; due.amount = Number(data.amount)||due.amount;
          if (due.status !== 'paid') due.remainingAmount = Number(data.amount)||due.remainingAmount;
          due.dueDate = data.dueDate; due.accountId = data.accountId; due.recurrence = data.recurrence;
          if (!due.originalDueDate) due.originalDueDate = data.dueDate;
          StorageService.save(); return true;
        },

        deleteDue(id){
          const due = this.getDueById(id);
          if (!due) return false;
          if (due.status === 'paid' && Array.isArray(due.payments) && due.payments.length) {
            for (const p of due.payments) {
              if (p.txId) {
                state.transactions = state.transactions.filter(t => t.id !== p.txId);
              }
            }
            due.status = 'pending';
            due.remainingAmount = due.amount;
            due.dueDate = due.originalDueDate || due.dueDate;
            due.payments = [];
            this.recalculateAllBalances(); StorageService.save();
            return 'restored';
          } else {
            state.payables = state.payables.filter(p => p.id !== id);
            StorageService.save();
            return 'deleted';
          }
        },

        applyPayment({ dueId, amount, accountId, notes, isCollection }) {
          const due = this.getDueById(dueId);
          if (!due) return { ok:false, msg:'Ø§Ù„Ø¨Ù†Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
          amount = Number(amount)||0;
          if (amount <= 0) return { ok:false, msg:'Ø§Ù„Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ§Ù„Ø­' };
          if (amount > due.remainingAmount + 0.0001) return { ok:false, msg:'Ø§Ù„Ù…Ø¨Ù„Øº Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ' };

          const nowIso = new Date().toISOString();
          let tx = null;
          if (isCollection) {
            tx = { id: cryptoUUID(), createdAt: nowIso, date: nowIso, type:'income', from:null, to: accountId, amount, category:'ØªØ­ØµÙŠÙ„', notes: notes || `ØªØ­ØµÙŠÙ„: ${due.name}` };
          } else {
            tx = { id: cryptoUUID(), createdAt: nowIso, date: nowIso, type:'expense', from:accountId, to:null, amount, category:'Ø³Ø¯Ø§Ø¯', notes: notes || `Ø³Ø¯Ø§Ø¯: ${due.name}` };
          }
          state.transactions.push(tx);

          due.payments = due.payments || [];
          due.payments.push({ amount, date: nowIso, accountId, txId: tx.id });

          due.remainingAmount = Math.max(0, Number(due.remainingAmount) - amount);

          if (due.remainingAmount <= 0.0001) {
            if (due.recurrence === 'monthly') {
              const next = new Date(due.dueDate);
              next.setMonth(next.getMonth()+1);
              due.dueDate = next.toISOString();
              due.remainingAmount = Number(due.amount) || 0;
              due.status = 'pending';
            } else {
              due.status = 'paid';
              if (!due.originalDueDate) due.originalDueDate = due.dueDate;
            }
          } else {
            due.status = 'pending';
          }

          this.recalculateAllBalances();
          StorageService.save();
          return { ok:true, txId: tx.id, due };
        },

        collectReceivablePartial(dueId, amount, accountId, notes=''){ const due = this.getDueById(dueId); if (!due || due.type !== 'receivable') return false; const res = this.applyPayment({ dueId, amount, accountId, notes, isCollection:true }); return res.ok; },
        payPayablePartial(dueId, amount, accountId, notes=''){ const due = this.getDueById(dueId); if (!due || due.type !== 'payable') return false; const res = this.applyPayment({ dueId, amount, accountId, notes, isCollection:false }); return res.ok; },

        getDuesWithStatus(){
          const today = new Date(); today.setHours(0,0,0,0);
          const sevenDays = new Date(today.getTime() + 7*24*60*60*1000);
          return state.payables.map(due => {
            const dueDate = new Date(due.dueDate); dueDate.setHours(0,0,0,0);
            let statusText = 'Ù…Ø³ØªØ­Ù‚';
            if (due.status === 'paid' && (due.recurrence === 'none' || !due.recurrence)) statusText='Ù…Ø¯ÙÙˆØ¹';
            else if (dueDate < today) statusText='Ù…ØªØ£Ø®Ø±';
            else if (dueDate <= sevenDays) statusText='Ù‚Ø±ÙŠØ¨ Ø§Ù„Ø§Ø³ØªØ­Ù‚Ø§Ù‚';
            if (due.remainingAmount === undefined || due.remainingAmount === null) due.remainingAmount = Number(due.amount) || 0;
            return { ...due, statusText };
          }).sort((a,b) => new Date(a.dueDate) - new Date(b.dueDate));
        },

        getFilteredTransactions(filters){
          const { account='all', type='all', dateStart='', dateEnd='' } = filters || {};
          return state.transactions.filter(tx => {
            if (account !== 'all' && tx.from !== account && tx.to !== account) return false;
            if (type !== 'all' && tx.type !== type) return false;
            if (dateStart) { if (formatDateISO(tx.date).slice(0,10) < dateStart) return false; }
            if (dateEnd) { if (formatDateISO(tx.date).slice(0,10) > dateEnd) return false; }
            return true;
          }).sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime());
        },

        getTopSpendingCategories(){
          const spending = {};
          state.transactions.forEach(tx => { if (tx.type === 'expense') { const cat = tx.category || 'ØºÙŠØ± Ù…ØµÙ†Ù'; spending[cat] = (spending[cat] || 0) + Number(tx.amount || 0); }});
          return Object.entries(spending).map(([category, amount]) => ({ category, amount })).sort((a,b)=>b.amount-a.amount).slice(0,5);
        },

        getDashboardSummary(){
          let income=0, expense=0;
          state.transactions.forEach(tx => { if (tx.type === 'income') income += Number(tx.amount)||0; else if (tx.type === 'expense') expense += Number(tx.amount)||0; });
          const totalBalance = state.accounts.reduce((s,a) => s + (Number(a.currentBalance)||0), 0);
          const today = new Date(); today.setHours(0,0,0,0);
          const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1); startOfMonth.setHours(0,0,0,0);
          const endOfMonth = new Date(startOfMonth); endOfMonth.setMonth(startOfMonth.getMonth()+1); endOfMonth.setDate(0); endOfMonth.setHours(23,59,59,999);
          
          let payablesRemaining = 0, receivablesUncollected = 0;
          state.payables.forEach(d => {
              if (d.status === 'pending' || d.status === 'partially_paid') {
                  const dueDate = new Date(d.dueDate);
                  if (d.type === 'payable') payablesRemaining += Number(d.remainingAmount || d.amount || 0);
                  if (d.type === 'receivable') receivablesUncollected += Number(d.remainingAmount || d.amount || 0);
              }
          });
          return { income, expense, net: income - expense, totalBalance, payablesRemaining, receivablesUncollected };
        }
      };

      // --- API layer ---
      const API = {
        // life-cycle
        init(){ StorageService.load(); CoreLogic.recalculateAllBalances(); return Promise.resolve(true); },

        // raw state (read-only copy)
        getState(){ return JSON.parse(JSON.stringify(state)); },

        // accounts
        listAccounts(){ return JSON.parse(JSON.stringify(state.accounts)); },
        getAccount(id){ return JSON.parse(JSON.stringify(CoreLogic.getAccountById(id))); },
        addAccount(name, initialBalance){ return CoreLogic.addAccount(name, initialBalance); },
        updateAccount(id, name, initialBalance){ return CoreLogic.updateAccount(id, name, initialBalance); },
        deleteAccount(id){ return CoreLogic.deleteAccount(id); },

        // transactions
        listTransactions(filters){ return CoreLogic.getFilteredTransactions(filters || {}); },
        getTransaction(id){ return JSON.parse(JSON.stringify(CoreLogic.getTransactionById(id))); },
        addTransaction(txData){ return CoreLogic.addTransaction(txData); },
        updateTransaction(id, txData){ return CoreLogic.updateTransaction(id, txData); },
        deleteTransaction(id){ return CoreLogic.deleteTransaction(id); },

        // dues
        listDues(){ return CoreLogic.getDuesWithStatus(); },
        getDue(id){ return JSON.parse(JSON.stringify(CoreLogic.getDueById(id))); },
        addDue(data){ return CoreLogic.addDue(data); },
        updateDue(id, data){ return CoreLogic.updateDue(id, data); },
        deleteDue(id){ return CoreLogic.deleteDue(id); },

        // payments
        applyPayment(args){ return CoreLogic.applyPayment(args); },
        collectReceivablePartial(dueId, amount, accountId, notes=''){ return CoreLogic.collectReceivablePartial(dueId, amount, accountId, notes); },
        payPayablePartial(dueId, amount, accountId, notes=''){ return CoreLogic.payPayablePartial(dueId, amount, accountId, notes); },

        // summary & helpers
        getDashboardSummary(){ return CoreLogic.getDashboardSummary(); },
        getTopSpendingCategories(){ return CoreLogic.getTopSpendingCategories(); },

        // storage
        exportData(){ return StorageService.exportData(); },
        importData(jsonStr){ return StorageService.importData(jsonStr); },
        resetToInitial(){ StorageService.saveInitial(); CoreLogic.recalculateAllBalances(); return true; }
      };

      global.DafatirAPI = API;

      StorageService.load();
      CoreLogic.recalculateAllBalances();

      console.info('DafatirAPI Ø¬Ø§Ù‡Ø². Ø§Ø³ØªØ®Ø¯Ù… ÙˆØ¸Ø§Ø¦ÙÙ‡ ÙÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ Ù„ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ©: DafatirAPI.addAccount(name, balance) Ùˆ DafatirAPI.addTransaction(txData)');
    
      // --- JavaScript for Rendering the UI and Theme Toggle (New Code) ---
      const langMap = {
          'payable': 'Ù…Ø·Ù„ÙˆØ¨ (Ø¯ÙØ¹)',
          'receivable': 'Ù…ØªÙˆÙ‚Ø¹ (ØªØ­ØµÙŠÙ„)',
      };
      
      const getAccountName = (id) => {
          const account = DafatirAPI.getAccount(id);
          return account ? account.name : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
      };
      
      const formatDate = (dateIso) => {
          return new Date(dateIso).toLocaleDateString('ar-EG', { year: 'numeric', month: 'short', day: 'numeric' });
      };


      function renderSummaryCards() {
        const summary = DafatirAPI.getDashboardSummary();
        const cardsContainer = document.getElementById('summary-cards');
        const summaryData = [
          { title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±ØµÙŠØ¯', value: formatCurrency(summary.totalBalance), class: 'total-balance', icon: 'ğŸ’°' },
          { title: 'Ø§Ù„Ø¥ÙŠØ±Ø§Ø¯Ø§Øª Ø§Ù„ÙƒÙÙ„ÙŠØ©', value: formatCurrency(summary.income), class: 'income', icon: 'â¬†ï¸' },
          { title: 'Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙƒÙÙ„ÙŠØ©', value: formatCurrency(summary.expense), class: 'expense', icon: 'â¬‡ï¸' },
          { title: 'ØµØ§ÙÙŠ Ø§Ù„Ø±ØµÙŠØ¯', value: formatCurrency(summary.net), class: 'net-balance', icon: 'âš–ï¸' },
          { title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù…Ø·Ù„ÙˆØ¨ Ø§Ù„Ø¯ÙØ¹', value: formatCurrency(summary.payablesRemaining), class: 'expense', icon: 'ğŸ—“ï¸' },
          { title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù…ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ­ØµÙŠÙ„', value: formatCurrency(summary.receivablesUncollected), class: 'income', icon: 'ğŸ“¥' },
        ];

        cardsContainer.innerHTML = summaryData.map(item => `
          <div class="card summary-item">
            <h2 class="card-title">${item.icon} ${item.title}</h2>
            <h3 class="${item.class} text-center">${item.value}</h3>
          </div>
        `).join('');
      }

      function renderAccountsTable() {
        const accounts = DafatirAPI.listAccounts();
        const tbody = document.querySelector('#accounts-table tbody');
        tbody.innerHTML = accounts.map(acc => `
          <tr>
            <td>${acc.name}</td>
            <td class="text-center ${acc.currentBalance < 0 ? 'text-danger' : 'text-success'}">${formatCurrency(acc.currentBalance)}</td>
          </tr>
        `).join('');
      }

      function renderDuesTable() {
        // Ø¹Ø±Ø¶ ÙÙ‚Ø· Ø§Ù„Ù…Ø³ØªØ­Ù‚Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø© Ø£Ùˆ Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©
        const dues = DafatirAPI.listDues().filter(d => d.statusText !== 'Ù…Ø¯ÙÙˆØ¹' || d.recurrence === 'monthly');
        const tbody = document.querySelector('#dues-table tbody');
        
        if (dues.length === 0) {
             tbody.innerHTML = '<tr><td colspan="6" class="text-center">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³ØªØ­Ù‚Ø§Øª Ù…Ø¹Ù„Ù‚Ø© Ø£Ùˆ Ù‚Ø§Ø¯Ù…Ø©.</td></tr>';
             return;
        }

        tbody.innerHTML = dues.map(due => {
          const dueDateStr = formatDate(due.dueDate);
          const statusClass = due.statusText.replace(/\s/g, '-');
          const isDanger = due.type === 'payable' && due.statusText !== 'Ù…Ø¯ÙÙˆØ¹';
          const isSuccess = due.type === 'receivable' && due.statusText !== 'Ù…Ø¯ÙÙˆØ¹';
          
          return `
            <tr>
              <td>${due.name}</td>
              <td class="text-center">${langMap[due.type]}</td>
              <td class="text-center">${dueDateStr}</td>
              <td class="text-center ${isDanger ? 'text-danger' : (isSuccess ? 'text-success' : '')}">${formatCurrency(due.remainingAmount)}</td>
              <td class="text-center">${getAccountName(due.accountId)}</td>
              <td class="text-center">
                <span class="status-badge status-${statusClass}">${due.statusText}</span>
              </td>
            </tr>
          `;
        }).join('');
      }
      
      function renderTopSpendingTable() {
          const topSpending = DafatirAPI.getTopSpendingCategories();
          const tbody = document.querySelector('#top-spending-table tbody');
          
          if (topSpending.length === 0) {
              tbody.innerHTML = '<tr><td colspan="2" class="text-center">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ØµØ±ÙˆÙØ§Øª Ù…Ø³Ø¬Ù„Ø© Ø¨Ø¹Ø¯.</td></tr>';
              return;
          }

          tbody.innerHTML = topSpending.map(item => `
              <tr>
                  <td>${item.category}</td>
                  <td class="text-center text-danger">${formatCurrency(item.amount)}</td>
              </tr>
          `).join('');
      }

      // -----------------------------------------------------------------
      // Theme Toggle Logic
      // -----------------------------------------------------------------
      function setupThemeToggle() {
          const toggleButton = document.getElementById('theme-toggle');
          
          // 1. Initial setup based on localStorage or system preference
          const storedTheme = localStorage.getItem('theme');
          if (storedTheme === 'dark') {
              document.documentElement.classList.add('dark-mode');
              toggleButton.textContent = 'â˜€ï¸';
          } else if (storedTheme === 'light') {
               document.documentElement.classList.remove('dark-mode');
               toggleButton.textContent = 'ğŸŒ™';
          } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              // Apply dark mode if system prefers it and no local storage preference
              document.documentElement.classList.add('dark-mode');
              toggleButton.textContent = 'â˜€ï¸';
          } else {
              toggleButton.textContent = 'ğŸŒ™';
          }

          // 2. Event Listener for manual toggle
          toggleButton.addEventListener('click', () => {
              const isDarkMode = document.documentElement.classList.toggle('dark-mode');
              if (isDarkMode) {
                  localStorage.setItem('theme', 'dark');
                  toggleButton.textContent = 'â˜€ï¸'; // Show Sun for light mode switch
              } else {
                  localStorage.setItem('theme', 'light');
                  toggleButton.textContent = 'ğŸŒ™'; // Show Moon for dark mode switch
              }
          });
      }
      // -----------------------------------------------------------------
      
      global.initializeDashboard = function() {
        DafatirAPI.init(); // Recalculate and load latest data
        renderSummaryCards();
        renderAccountsTable();
        renderDuesTable();
        renderTopSpendingTable();
      };
      
      // ØªÙ†ÙÙŠØ° ØªÙ‡ÙŠØ¦Ø© Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø¯Ø© ÙˆØªÙØ¹ÙŠÙ„ Ø²Ø± Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù€ DOM
      window.addEventListener('DOMContentLoaded', () => {
          setupThemeToggle();
          initializeDashboard();
      });

    })(window);
  </script>
</body>
</html>
